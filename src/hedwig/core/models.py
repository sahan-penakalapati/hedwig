"""
Core data models for the Hedwig multi-agent system.

These models define the standardized communication structures between
agents, tools, and the application layer.
"""

from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, field_validator


class ErrorCode(str, Enum):
    """Standard error codes for programmatic error handling."""
    
    TASK_REJECTED_AS_INAPPROPRIATE = "TASK_REJECTED_AS_INAPPROPRIATE"
    SECURITY_GATEWAY_DENIAL = "SECURITY_GATEWAY_DENIAL"
    TOOL_EXECUTION_FAILED = "TOOL_EXECUTION_FAILED"
    AGENT_EXECUTION_FAILED = "AGENT_EXECUTION_FAILED"
    ARTIFACT_NOT_FOUND = "ARTIFACT_NOT_FOUND"
    INVALID_INPUT = "INVALID_INPUT"
    TIMEOUT_EXCEEDED = "TIMEOUT_EXCEEDED"
    CONFIGURATION_ERROR = "CONFIGURATION_ERROR"


class RiskTier(str, Enum):
    """Risk tiers for security assessment of tool operations."""
    
    READ_ONLY = "READ_ONLY"
    WRITE = "WRITE" 
    EXECUTE = "EXECUTE"
    DESTRUCTIVE = "DESTRUCTIVE"


class ArtifactType(str, Enum):
    """Types of artifacts that can be generated by tools."""
    
    PDF = "pdf"
    MARKDOWN = "markdown"
    CODE = "code"
    RESEARCH = "research"
    OTHER = "other"


class Artifact(BaseModel):
    """
    Represents a file or output generated by a tool during task execution.
    
    Artifacts are the primary way tools communicate file creation back to
    the application layer for tracking and user presentation.
    """
    
    file_path: str = Field(..., description="Path to the artifact file")
    artifact_type: ArtifactType = Field(..., description="Type classification of the artifact")
    description: str = Field(..., description="Human-readable description of the artifact")
    created_at: datetime = Field(default_factory=datetime.now, description="Creation timestamp")
    artifact_id: UUID = Field(default_factory=uuid4, description="Unique identifier for the artifact")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    
    @field_validator('file_path')
    @classmethod
    def validate_file_path(cls, v):
        """Ensure file path is valid."""
        if not v or not isinstance(v, str):
            raise ValueError("file_path must be a non-empty string")
        return v
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert artifact to dictionary for serialization."""
        return {
            "file_path": self.file_path,
            "artifact_type": self.artifact_type.value,
            "description": self.description,
            "created_at": self.created_at.isoformat(),
            "artifact_id": str(self.artifact_id),
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Artifact":
        """Create artifact from dictionary."""
        return cls(
            file_path=data["file_path"],
            artifact_type=ArtifactType(data["artifact_type"]),
            description=data["description"],
            created_at=datetime.fromisoformat(data["created_at"]),
            artifact_id=UUID(data["artifact_id"]),
            metadata=data.get("metadata", {})
        )


class ToolOutput(BaseModel):
    """
    Structured output from tool execution.
    
    This replaces fragile text parsing with a reliable communication
    protocol between tools and agents.
    """
    
    text_summary: str = Field(..., description="Human/LLM-readable summary of the tool execution")
    artifacts: List[Artifact] = Field(default_factory=list, description="List of artifacts created by the tool")
    success: bool = Field(default=True, description="Whether the tool execution succeeded")
    error: Optional[str] = Field(None, description="Error message if execution failed")
    error_message: Optional[str] = Field(None, description="Alias for error field for compatibility")
    error_code: Optional[ErrorCode] = Field(None, description="Standard error code for programmatic handling")
    raw_content: Optional[Any] = Field(None, description="Raw tool output content for agent processing")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional execution metadata")
    
    def add_artifact(self, artifact: Artifact) -> None:
        """Add an artifact to the output."""
        self.artifacts.append(artifact)
    
    def has_artifacts(self) -> bool:
        """Check if any artifacts were generated."""
        return len(self.artifacts) > 0


class TaskInput(BaseModel):
    """
    Input structure for agent task execution.
    
    Provides standardized way to pass task parameters and context to agents.
    """
    
    prompt: str = Field(..., description="The user's task prompt")
    parameters: Dict[str, Any] = Field(default_factory=dict, description="Optional task parameters")
    tools: Optional[List[str]] = Field(None, description="Optional list of specific tools to use")
    conversation: List[Dict[str, str]] = Field(default_factory=list, description="Conversation history")
    thread_id: Optional[UUID] = Field(None, description="Chat thread identifier")
    
    @field_validator('prompt')
    @classmethod
    def validate_prompt(cls, v):
        """Ensure prompt is not empty."""
        if not v or not v.strip():
            raise ValueError("prompt cannot be empty")
        return v.strip()


class TaskOutput(BaseModel):
    """
    Output structure from agent task execution.
    
    Standardized response format that includes success status, content,
    and any artifacts generated during execution.
    """
    
    content: str = Field(..., description="Generated response content")
    success: bool = Field(default=True, description="Whether the task completed successfully")
    result: Optional[Any] = Field(None, description="Raw result data")
    error: Optional[str] = Field(None, description="Error message if task failed")
    error_code: Optional[ErrorCode] = Field(None, description="Standard error code")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Task execution metadata")
    artifacts: List[Artifact] = Field(default_factory=list, description="Artifacts generated during execution")
    conversation: List[Dict[str, str]] = Field(default_factory=list, description="Updated conversation history")
    
    def add_artifact(self, artifact: Artifact) -> None:
        """Add an artifact to the task output."""
        self.artifacts.append(artifact)
    
    def has_artifacts(self) -> bool:
        """Check if any artifacts were generated."""
        return len(self.artifacts) > 0
    
    def get_artifacts_by_type(self, artifact_type: ArtifactType) -> List[Artifact]:
        """Get all artifacts of a specific type."""
        return [a for a in self.artifacts if a.artifact_type == artifact_type]


class AgentDescription(BaseModel):
    """
    Structured description of an agent for dispatcher routing.
    
    Each specialist agent must provide this information to enable
    intelligent task routing by the DispatcherAgent.
    """
    
    agent_name: str = Field(..., description="Unique name of the agent")
    purpose: str = Field(..., description="One-sentence description of the agent's primary function")
    capabilities: List[str] = Field(..., description="List of specific abilities/keywords")
    example_tasks: List[str] = Field(..., description="2-3 concrete example prompts the agent handles")
    
    @field_validator('capabilities')
    @classmethod
    def validate_capabilities(cls, v):
        """Ensure capabilities list is not empty."""
        if not v:
            raise ValueError("capabilities cannot be empty")
        return v
    
    @field_validator('example_tasks')
    @classmethod
    def validate_example_tasks(cls, v):
        """Ensure example tasks are provided."""
        if not v:
            raise ValueError("example_tasks cannot be empty")
        return v


class ConversationMessage(BaseModel):
    """Individual message in a conversation thread."""
    
    role: str = Field(..., description="Message role (user, assistant, system)")
    content: str = Field(..., description="Message content")
    timestamp: datetime = Field(default_factory=datetime.now, description="Message timestamp")
    message_id: UUID = Field(default_factory=uuid4, description="Unique message identifier")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Message metadata")
    
    @field_validator('role')
    @classmethod
    def validate_role(cls, v):
        """Ensure role is valid."""
        valid_roles = {'user', 'assistant', 'system'}
        if v not in valid_roles:
            raise ValueError(f"role must be one of {valid_roles}")
        return v


class ChatThread(BaseModel):
    """
    Represents a complete chat thread with conversation history and artifacts.
    
    Each user interaction is encapsulated within a distinct chat thread to
    maintain context and associate artifacts with their generating conversation.
    """
    
    thread_id: UUID = Field(default_factory=uuid4, description="Unique thread identifier")
    created_at: datetime = Field(default_factory=datetime.now, description="Thread creation timestamp")
    updated_at: datetime = Field(default_factory=datetime.now, description="Last update timestamp")
    messages: List[ConversationMessage] = Field(default_factory=list, description="Conversation messages")
    artifacts: List[Artifact] = Field(default_factory=list, description="Thread-scoped artifacts")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Thread metadata")
    
    def add_message(self, role: str, content: str, metadata: Optional[Dict[str, Any]] = None) -> ConversationMessage:
        """Add a message to the conversation."""
        message = ConversationMessage(
            role=role,
            content=content,
            metadata=metadata or {}
        )
        self.messages.append(message)
        self.updated_at = datetime.now()
        return message
    
    def add_artifact(self, artifact: Artifact) -> None:
        """Add an artifact to the thread."""
        self.artifacts.append(artifact)
        self.updated_at = datetime.now()
    
    def get_conversation_history(self) -> List[Dict[str, str]]:
        """Get conversation history in simple dict format."""
        return [
            {"role": msg.role, "content": msg.content}
            for msg in self.messages
        ]